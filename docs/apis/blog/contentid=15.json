{"status":"success","code":200,"data":{"id":15,"title":"TypeScript学习---联想壁纸库","desc":"之前做的壁纸网，其实就是从慕课网看到的一个项目，虽说没买。但是它提供了学习文档，我看写的挺好，就根据文档中Ts和Vue 3学习了一番，然后就写了个壁纸网，文档介绍了Ts和Vue 3的新特性。有兴趣的可以看看！","content":"本文来自于[http://docs.vikingship.xyz/typescript.html](http://docs.vikingship.xyz/typescript.html)\n根据本文的学习，完成了本项目[https://gitee.com/baymaxsjj/by-vue-wallpaper](https://gitee.com/baymaxsjj/by-vue-wallpaper)\n## 安装 Typescript\n\n**Typescript 官网地址**: https://www.typescriptlang.org/zh/\n\n使用 nvm 来管理 node 版本: https://github.com/nvm-sh/nvm\n\n安装 Typescript:\n\n```bash\nnpm install -g typescript\n```\n\n使用 tsc 全局命令：\n\n```bash\n// 查看 tsc 版本\ntsc -v\n// 编译 ts 文件\ntsc fileName.ts\n```\n\n## 原始数据类型\n\nTypescript 文档地址：[Basic Types](https://www.typescriptlang.org/docs/handbook/basic-types.html#boolean)\n\nJavascript 类型分类：\n\n原始数据类型 - primitive values：\n\n- Boolean\n- Null\n- Undefined\n- Number\n- BigInt\n- String\n- Symbol\n\n```javascript\nlet isDone: boolean = false\n\n// 接下来来到 number，注意 es6 还支持2进制和8进制，让我们来感受下\n\nlet age: number = 10\nlet binaryNumber: number = 0b1111\n\n// 之后是字符串，注意es6新增的模版字符串也是没有问题的\nlet firstName: string = 'viking'\nlet message: string = `Hello, ${firstName}, age is ${age}`\n\n// 还有就是两个奇葩兄弟两，undefined 和 null\nlet u: undefined = undefined\nlet n: null = null\n\n// 注意 undefined 和 null 是所有类型的子类型。也就是说 undefined 类型的变量，可以赋值给 number 类型的变量：\nlet num: number = undefined\n```\n\n[any 类型](https://www.typescriptlang.org/docs/handbook/basic-types.html#any)\n\n```javascript\nlet notSure: any = 4\nnotSure = 'maybe it is a string'\nnotSure = 'boolean'\n// 在任意值上访问任何属性都是允许的：\nnotSure.myName\n// 也允许调用任何方法：\nnotSure.getName()\n```\n\n## Array 和 Tuple\n\nTypescript 文档地址：[Array 和 Tuple](https://www.typescriptlang.org/docs/handbook/basic-types.html#array)\n\n```javascript\n//最简单的方法是使用「类型 + 方括号」来表示数组：\nlet arrOfNumbers: number[] = [1, 2, 3, 4]\n//数组的项中不允许出现其他的类型：\n//数组的一些方法的参数也会根据数组在定义时约定的类型进行限制：\narrOfNumbers.push(3)\narrOfNumbers.push('abc')\n\n// 元祖的表示和数组非常类似，只不过它将类型写在了里面 这就对每一项起到了限定的作用\nlet user: [string, number] = ['viking', 20]\n//但是当我们写少一项 就会报错 同样写多一项也会有问题\nuser = ['molly', 20, true]\n```\n\n## interface 接口\n\nTypescript 文档地址：[Interface](https://www.typescriptlang.org/docs/handbook/interfaces.html)\n\nDuck Typing 概念：\n\n> 如果某个东西长得像鸭子，像鸭子一样游泳，像鸭子一样嘎嘎叫，那它就可以被看成是一只鸭子。\n\n```javascript\n// 我们定义了一个接口 Person\ninterface Person {\n  name: string;\n  age: number;\n}\n// 接着定义了一个变量 viking，它的类型是 Person。这样，我们就约束了 viking 的形状必须和接口 Person 一致。\nlet viking: Person ={\n  name: 'viking',\n  age: 20\n}\n\n//有时我们希望不要完全匹配一个形状，那么可以用可选属性：\ninterface Person {\n    name: string;\n    age?: number;\n}\nlet viking: Person = {\n    name: 'Viking'\n}\n\n//接下来还有只读属性，有时候我们希望对象中的一些字段只能在创建的时候被赋值，那么可以用 readonly 定义只读属性\n\ninterface Person {\n  readonly id: number;\n  name: string;\n  age?: number;\n}\nviking.id = 9527\n```\n\n## 函数\n\nTypescript 文档地址：[Functions](https://www.typescriptlang.org/docs/handbook/functions.html)\n\n```javascript\n// 来到我们的第一个例子，约定输入，约定输出\nfunction add(x: number, y: number): number {\n  return x + y\n}\n// 可选参数\nfunction add(x: number, y: number, z?: number): number {\n  if (typeof z === 'number') {\n    return x + y + z\n  } else {\n    return x + y\n  }\n}\n\n// 函数本身的类型\nconst add2: (x: number, y: number, z?:number) => number = add\n\n// interface 描述函数类型\nconst sum = (x: number, y: number) => {\n  return x + y\n}\ninterface ISum {\n  (x: number, y: number): number\n}\nconst sum2: ISum = sum\n```\n\n## 类型推论，联合类型 和 类型断言\n\nTypescript 文档地址：[类型推论 - type inference](https://www.typescriptlang.org/docs/handbook/type-inference.html)\n\n[联合类型 - union types](https://www.typescriptlang.org/docs/handbook/unions-and-intersections.html#union-types)\n\n```javascript\n// 我们只需要用中竖线来分割两个\nlet numberOrString: number | string \n// 当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法：\nnumberOrString.length\nnumberOrString.toString()\n```\n\n[类型断言 - type assertions](https://www.typescriptlang.org/docs/handbook/basic-types.html#type-assertions)\n\n```javascript\n// 这里我们可以用 as 关键字，告诉typescript 编译器，你没法判断我的代码，但是我本人很清楚，这里我就把它看作是一个 string，你可以给他用 string 的方法。\nfunction getLength(input: string | number): number {\n  const str = input as string\n  if (str.length) {\n    return str.length\n  } else {\n    const number = input as number\n    return number.toString().length\n  }\n}\n```\n\n[类型守卫 - type guard](https://www.typescriptlang.org/docs/handbook/advanced-types.html#type-guards-and-differentiating-types)\n\n```javascript\n// typescript 在不同的条件分支里面，智能的缩小了范围，这样我们代码出错的几率就大大的降低了。\nfunction getLength2(input: string | number): number {\n  if (typeof input === 'string') {\n    return input.length\n  } else {\n    return input.toString().length\n  }\n}\n```\n\n## Class 类\n\n面向对象编程的三大特点\n\n- **封装（Encapsulation）**：将对数据的操作细节隐藏起来，只暴露对外的接口。外界调用端不需要（也不可能）知道细节，就能通过对外提供的接口来访问该对象，\n- **继承（Inheritance）**：子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性。\n- **多态（Polymorphism）**：由继承而产生了相关的不同的类，对同一个方法可以有不同的响应。\n\n[类 - Class](https://www.typescriptlang.org/docs/handbook/classes.html)\n\n```javascript\nclass Animal {\n  name: string;\n  constructor(name: string) {\n    this.name = name\n  }\n  run() {\n    return `${this.name} is running`\n  }\n}\nconst snake = new Animal('lily')\n\n// 继承的特性\nclass Dog extends Animal {\n  bark() {\n    return `${this.name} is barking`\n  }\n}\n\nconst xiaobao = new Dog('xiaobao')\nconsole.log(xiaobao.run())\nconsole.log(xiaobao.bark())\n\n// 这里我们重写构造函数，注意在子类的构造函数中，必须使用 super 调用父类的方法，要不就会报错。\nclass Cat extends Animal {\n  constructor(name) {\n    super(name)\n    console.log(this.name)\n  }\n  run() {\n    return 'Meow, ' + super.run()\n  }\n}\nconst maomao = new Cat('maomao')\nconsole.log(maomao.run())\n```\n\n[类成员的访问修饰符](https://www.typescriptlang.org/docs/handbook/classes.html#public-private-and-protected-modifiers)\n\n- **public** 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 public 的\n- **private** 修饰的属性或方法是私有的，不能在声明它的类的外部访问\n- **protected** 修饰的属性或方法是受保护的，它和 private 类似，区别是它在子类中也是允许被访问的\n\n## 类与接口\n\n[类实现一个接口](https://www.typescriptlang.org/docs/handbook/interfaces.html#class-types)\n\n```javascript\ninterface Radio {\n  switchRadio(trigger: boolean): void;\n}\nclass Car implements Radio {\n  switchRadio(trigger) {\n    return 123\n  }\n}\nclass Cellphone implements Radio {\n  switchRadio() {\n  }\n}\n\ninterface Battery {\n  checkBatteryStatus(): void;\n}\n\n// 要实现多个接口，我们只需要中间用 逗号 隔开即可。\nclass Cellphone implements Radio, Battery {\n  switchRadio() {\n  }\n  checkBatteryStatus() {\n\n  }\n}\n```\n\n## 枚举 Enums\n\n[枚举 Enums](https://www.typescriptlang.org/docs/handbook/enums.html)\n\n```javascript\n// 数字枚举，一个数字枚举可以用 enum 这个关键词来定义，我们定义一系列的方向，然后这里面的值，枚举成员会被赋值为从 0 开始递增的数字,\nenum Direction {\n  Up,\n  Down,\n  Left,\n  Right,\n}\nconsole.log(Direction.Up)\n\n// 还有一个神奇的点是这个枚举还做了反向映射\nconsole.log(Direction[0])\n\n// 字符串枚举\nenum Direction {\n  Up = 'UP',\n  Down = 'DOWN',\n  Left = 'LEFT',\n  Right = 'RIGHT',\n}\nconst value = 'UP'\nif (value === Direction.Up) {\n  console.log('go up!')\n}\n```\n\n## 泛型 Generics\n\n[泛型 Generics](https://www.typescriptlang.org/docs/handbook/generics.html)\n\n泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。\n\n```javascript\nfunction echo(arg) {\n  return arg\n}\nconst result = echo(123)\n// 这时候我们发现了一个问题，我们传入了数字，但是返回了 any\n\nfunction echo<T>(arg: T): T {\n  return arg\n}\nconst result = echo(123)\n\n// 泛型也可以传入多个值\nfunction swap<T, U>(tuple: [T, U]): [U, T] {\n  return [tuple[1], tuple[0]]\n}\n\nconst result = swap(['string', 123])\n```\n\n## 泛型第二部分 - 泛型约束\n\n在函数内部使用泛型变量的时候，由于事先不知道它是哪种类型，所以不能随意的操作它的属性或方法\n\n```javascript\nfunction echoWithArr<T>(arg: T): T {\n  console.log(arg.length)\n  return arg\n}\n\n// 上例中，泛型 T 不一定包含属性 length，我们可以给他传入任意类型，当然有些不包括 length 属性，那样就会报错\n\ninterface IWithLength {\n  length: number;\n}\nfunction echoWithLength<T extends IWithLength>(arg: T): T {\n  console.log(arg.length)\n  return arg\n}\n\nechoWithLength('str')\nconst result3 = echoWithLength({length: 10})\nconst result4 = echoWithLength([1, 2, 3])\n```\n\n##  泛型第三部分 - 泛型与类和接口\n\n```javascript\nclass Queue {\n  private data = [];\n  push(item) {\n    return this.data.push(item)\n  }\n  pop() {\n    return this.data.shift()\n  }\n}\n\nconst queue = new Queue()\nqueue.push(1)\nqueue.push('str')\nconsole.log(queue.pop().toFixed())\nconsole.log(queue.pop().toFixed())\n\n//在上述代码中存在一个问题，它允许你向队列中添加任何类型的数据，当然，当数据被弹出队列时，也可以是任意类型。在上面的示例中，看起来人们可以向队列中添加string 类型的数据，但是那么在使用的过程中，就会出现我们无法捕捉到的错误，\n\nclass Queue<T> {\n  private data = [];\n  push(item: T) {\n    return this.data.push(item)\n  }\n  pop(): T {\n    return this.data.shift()\n  }\n}\nconst queue = new Queue<number>()\n\n//泛型和 interface\ninterface KeyPair<T, U> {\n  key: T;\n  value: U;\n}\n\nlet kp1: KeyPair<number, string> = { key: 1, value: \"str\"}\nlet kp2: KeyPair<string, number> = { key: \"str\", value: 123}\n```\n\n##  类型别名 和 交叉类型\n\n[类型别名 Type Aliases](https://www.typescriptlang.org/docs/handbook/advanced-types.html#type-aliases)\n\n类型别名，就是给类型起一个别名，让它可以更方便的被重用。\n\n```javascript\nlet sum: (x: number, y: number) => number\nconst result = sum(1,2)\ntype PlusType = (x: number, y: number) => number\nlet sum2: PlusType\n\n// 支持联合类型\ntype StrOrNumber = string | number\nlet result2: StrOrNumber = '123'\nresult2 = 123\n\n// 字符串字面量\ntype Directions = 'Up' | 'Down' | 'Left' | 'Right'\nlet toWhere: Directions = 'Up'\n```\n\n[交叉类型 Intersection Types](https://www.typescriptlang.org/docs/handbook/unions-and-intersections.html#intersection-types)\n\n```javascript\ninterface IName  {\n  name: string\n}\ntype IPerson = IName & { age: number }\nlet person: IPerson = { name: 'hello', age: 12}\n```\n\n##  声明文件\n\n[声明文件](https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html)\n\n[@types 官方声明文件库](https://github.com/DefinitelyTyped/DefinitelyTyped/) [@types 搜索声明库](https://microsoft.github.io/TypeSearch/)\n\n##  内置类型\n\n[内置类型](https://github.com/Microsoft/TypeScript/tree/master/src/lib)\n\n```javascript\nconst a: Array<number> = [1,2,3]\n// 大家可以看到这个类型，不同的文件中有多处定义，但是它们都是 内部定义的一部分，然后根据不同的版本或者功能合并在了一起，一个interface 或者 类多次定义会合并在一起。这些文件一般都是以 lib 开头，以 d.ts 结尾，告诉大家，我是一个内置对象类型欧\nconst date: Date = new Date()\nconst reg = /abc/\n// 我们还可以使用一些 build in object，内置对象，比如 Math 与其他全局对象不同的是，Math 不是一个构造器。Math 的所有属性与方法都是静态的。\n\nMath.pow(2,2)\n\n// DOM 和 BOM 标准对象\n// document 对象，返回的是一个 HTMLElement\nlet body: HTMLElement = document.body\n// document 上面的query 方法，返回的是一个 nodeList 类型\nlet allLis = document.querySelectorAll('li')\n\n//当然添加事件也是很重要的一部分，document 上面有 addEventListener 方法，注意这个回调函数，因为类型推断，这里面的 e 事件对象也自动获得了类型，这里是个 mouseEvent 类型，因为点击是一个鼠标事件，现在我们可以方便的使用 e 上面的方法和属性。\ndocument.addEventListener('click', (e) => {\n  e.preventDefault()\n})\n```\n\n[Utility Types](https://www.typescriptlang.org/docs/handbook/utility-types.html)\n\nTypescript 还提供了一些功能性，帮助性的类型，这些类型，大家在 js 的世界是看不到的，这些类型叫做 utility types，提供一些简洁明快而且非常方便的功能。\n\n```javascript\n// partial，它可以把传入的类型都变成可选\ninterface IPerson {\n  name: string\n  age: number\n}\n\nlet viking: IPerson = { name: 'viking', age: 20 }\ntype IPartial = Partial<IPerson>\nlet viking2: IPartial = { }\n\n// Omit，它返回的类型可以忽略传入类型的某个属性\n\ntype IOmit = Omit<IPerson, 'name'>\nlet viking3: IOmit = { age: 20 }\n```","img":"https://p.pstatp.com/origin/1373c0002c8d752a6c8fb","classty":"前端","channels":null,"name":"云墨白","click":1,"like":1,"is_show":1,"head_show":1,"share_show":1,"copyright_show":0,"message_show":1,"deleted_at":1,"created_at":"2020-11-04T08:44:24.000000Z","updated_at":"2020-12-16T11:40:39.000000Z","label":["Ts"],"view_count":1,"prevArticle":[{"id":14,"title":"Vue3+TypeScript学习之旅---联想壁纸库项目部署"}],"nextrAticle":[{"id":16,"title":"博客Vue3重构计划，最新音乐播放器，进来瞅瞅！"}]}}