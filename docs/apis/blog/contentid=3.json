{"status":"success","code":200,"data":{"id":3,"title":"Vue博客前端总结——项目配置","desc":"一个项目的配置尤为重要,正确的配置解决了ie空白，路由懒加载防止页面加载太长。开发和生产环境不同要求配置，多页面配置（前台和后台在一个项目中），跨域问题等等。这些配置如果配置好，我相信能够为你解决不少问题和时间。","content":"## 前言\n![在这里插入图片描述](https://img-blog.csdnimg.cn/cover1/237894441851158706.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,image_MjAyMDA3MTUxNjIxMDEzOC5wbmc=,size_16,color_FFFFFF,t_70,image/resize,m_lfit,w_962#pic_center)\n\n一个项目的配置尤为重要，在博客项目中碰到了很多的坑，大部分都是由于配置导致的。这些配置解决了ie空白，路由懒加载防止页面加载太长。开发和生产环境不同要求配置，多页面配置（前台和后台在一个项目中），跨域问题等等。这些配置如果配置好，我相信能够为你解决不少问题和时间。\n\n### 环境变量\n\n> env 文件需要声明运行的环境\n\n使`vue.config.js`中根据不同环境进行配置\n\n#### .env.development\n\n```JavaScript\nNODE_ENV = development\n```\n\n#### .env.production\n\n```JavaScript\nNODE_ENV = production\n```\n\n#### .env.development\n\n> 定义变量需要以 VUE_APP_ 作为前缀\n\n```JavaScript\nNODE_ENV = development\nVUE_APP_BASE_URL = http://dev.myhost.com\n```\n\n> 测试变量是否生效, 可直接在 main.js 中打印测试、\n\n```javascript\nconsole.log(process.env.VUE_APP_BASE_URL);\n```\n\n### vue.config.js配置\n\n> vue.config.js 是一个可选的配置文件，如果项目的 (和 package.json 同级的) 根目录中存在这个文件，那么它会被 @vue/cli-service 自动加载。你也可以使用 package.json 中的 vue 字段，但是注意这种写法需要你严格遵照 JSON 的格式来写。详情配置请参考----[Vue Cli 参考配置](https://cli.vuejs.org/zh/config/#%E5%85%A8%E5%B1%80-cli-%E9%85%8D%E7%BD%AE)\n\n此项配置了代码压缩，解决了ie空白，多页面配置，跨域（部分接口来自第三方网站），此配置文件根据具体需求配置。不适用其它项目。具体可以参考[vue-cli4 全面配置(持续更新)](https://github.com/staven630/vue-cli4-config)\n\n```JavaScript\nconst CompressionWebpackPlugin = require('compression-webpack-plugin'); // gzip 压缩\nconst productionGzipExtensions = ['js', 'html', 'css'];\n// 代码压缩\nconst UglifyJsPlugin = require('uglifyjs-webpack-plugin');\n//是否为生产环境\nconst IS_PROD = process.env.NODE_ENV === 'production';\nmodule.exports = {\n    //这个选项终于解决了Ie下空白的问题。如果项目在ie空白，就要配置此选项，主要原因在于第三方插件\n    //默认情况下 babel-loader 会忽略所有 node_modules 中的文件。  \n    //如果你想要通过 Babel 显式转译一个依赖，可以在这个选项中列出来\n    transpileDependencies: ['vue-savedata', 'vue-baberrage'],\n    //多页面配置，因为我都前台和后台都在一个项目中。\n    //每个“page”应该有一个对应的 JavaScript 入口文件\n    pages: {\n        about: {\n            entry: 'src/pages/admin/main.js',\n            template: 'public/admin.html',\n            filename: 'admin.html',\n            chunks: ['chunk-vendors', 'chunk-common', 'about'],\n            title: 'BAYMAX后台管理'\n        },\n        index: {\n            entry: 'src/pages/home/main.js',\n            template: 'public/index.html',\n            filename: 'index.html',\n            chunks: ['chunk-vendors', 'chunk-common', 'index'],\n            title: '云墨白'\n        }\n    },\n    //如果你的前端应用和后端 API 服务器没有运行在同一个主机上，你需要在开发环境下\t \n    //将 API 请求代理到 API 服务器。这个问题可以通过 vue.config.js 中的devServer.proxy 选项来配置。在nginx配置请看下一节\n    devServer: {\n        sockHost: \"localhost\",\n        disableHostCheck: true,\n        port: 8080, // 端口号\n        host: \"0.0.0.0\",\n        https: false, // https:{type:Boolean}\n        open: true, //配置自动启动浏览器\n        proxy: {\n            \"/apis\": {\n                // target: \"http://127.0.0.1:80/api/v1\", // 需要请求的地址\n                target: process.env.VUE_APP_API_URL, // 需要请求的地址\n                changeOrigin: true, // 是否跨域\n                pathRewrite: {\n                    \"^/apis\": \"\" // 替换target中的请求地址，也就是说，在请求的时候，url用'/apis'代替'url'\n                }\n            },\n            \"/music\": {\n                target: \"url\", // 需要请求的地址\n                // target: process.env.VUE_APP_URL,   // 需要请求的地址\n                changeOrigin: true, // 是否跨域\n                pathRewrite: {\n                    \"^/music\": \"\" // 替换target中的请求地址，也就是说，在请求的时候，url用'/music'代替'url\n                }\n            },\n            \"/english\": {\n                target: \"url\", // 需要请求的地址\n                // target: process.env.VUE_APP_URL,   // 需要请求的地址\n                changeOrigin: true, // 是否跨域\n                pathRewrite: {\n                    \"^/english\": \"\" // 替换target中的请求地址，也就是说，在请求的时候，url用'/english'代替'url'\n                }\n            }\n        }\n    },\n    productionSourceMap: !IS_PROD,\n    configureWebpack: config => {\n        // 用cdn方式引入，则构建时要忽略相关资源\n        config.externals = {\n            \"mavon-editor\": \"MavonEditor\",\n            // vue: \"Vue\",\n            // \"element-ui\": \"ELEMENT\",\n            // \"vue-router\": \"VueRouter\",\n            // vuex: \"Vuex\",\n            // axios: \"axios\"\n        };\n\n        if (IS_PROD) {\n\n            //gzip压缩\n            config.plugins.push(new CompressionWebpackPlugin({\n                algorithm: 'gzip',\n                test: new RegExp('\\\\.(' + productionGzipExtensions.join('|') + ')$'), //匹配文件名\n                threshold: 10240, //对超过10k的数据进行压缩\n                minRatio: 0.8,\n                deleteOriginalAssets: false //是否删除原文件\n            }));\n         \n            // 代码压缩\n            config.plugins.push(\n                new UglifyJsPlugin({\n                    uglifyOptions: {\n                        //生产环境自动删除console\n                        compress: {\n                            // warnings: false, // 若打包错误，则注释这行\n                            drop_debugger: true,\n                            drop_console: true,\n                            pure_funcs: ['console.log']\n                        }\n                    },\n                    sourceMap: false,\n                    parallel: true\n                })\n            )\n\n        }\n    },\n    chainWebpack: config => {\n        if (IS_PROD) {\n            // 删除预加载\n            config.plugins.delete('preload');\n            config.plugins.delete('prefetch');\n            // 压缩代码\n            config.optimization.minimize(true);\n            // ============压缩图片 start============\n            config.module\n                .rule('images')\n                .use('image-webpack-loader')\n                .loader('image-webpack-loader')\n                .options({ bypassOnDebug: true })\n                .end()\n                // ============压缩图片 end============\n        }\n        return config;\n    }\n}\n\n```\n\n### nginx服务器配置\n\n **反向代理用来解决前端跨域问题** 此配置在服务器配置，本地只需在`vue.config.js`中配置\n\n```javascript\n//Vue 路由history模式下需配置,配置路由跳转会出现404\nlocation / {\n      try_files $uri $uri/ /index.html;\n    }\n//反向代理\n    location /apis {\n        add_header 'Access-Control-Allow-Origin' '*';\n        proxy_pass url;\n    }\n     location /music {\n        proxy_pass url;\n    }\n    location /english {\n        proxy_pass url;\n    }\n```\n\n### axios配置\n\n> 易用、简洁且高效的http库。详情配置请参考---[axios中文文档](http://www.axios-js.com/zh-cn/docs/)\n\n```JavaScript\nimport axios from 'axios'\nimport store from '../pages/home/store'\nimport { Notification } from 'element-ui';\nimport router from '@/pages/home/router'\n//\nvar instance = axios.create({\n//请求地址\n    baseURL: process.env.VUE_APP_URL,\n//超时时间\n    timeout: 10000,\n});\n// 添加请求拦截器\ninstance.interceptors.request.use(function(config) {\n    // 在发送请求之前做些什么\n    config.headers['Authorization'] = store.state.user.token\n    config.headers['X-Requested-With'] = 'XMLHttpRequest'\n    return config;\n}, function(error) {\n    // 对请求错误做些什么\n    return Promise.reject(error);\n});\n\n// 添加响应拦截器\n//全局统一的错误拦截，需要跟后端统一\ninstance.interceptors.response.use(function(response) {\n        // 对响应数据做点什么\n        // Message('操作成功')\n        if (response.headers.authorization) {\n            store.dispatch(\"setToken\", response.headers.authorization);\n        }\n        console.log(response.status)\n        if (response.data.status == 'success') {\n            return Promise.resolve(response.data)\n        } else if (response.data.status == 'error') {\n            Notification.error({\n                title: '错误提示',\n                message: response.data.message,\n            })\n        } else if (response.data.code == 200 || response.status == 200) {\n            return Promise.resolve(response.data)\n        } else {\n            Notification.error({\n                title: '错误提示',\n                message: response.data.message,\n            })\n        }\n        // 打印错误信息\n        return Promise.reject(response.data)\n    },\n    function(error) {\n        // 对响应错误做点什么\n        switch (error.response.status) {\n            case 400:\n                Notification.warning({\n                    title: '用户登录提示',\n                    message: error.response.data.message,\n                    onClose() {\n                        store.dispatch(\"Logout\");\n                        router.push('/login')\n                    },\n                });\n                break;\n            case 401:\n                Notification.warning({\n                    title: '请求参数有误',\n                    message: error.response.data.message,\n                });\n                break;\n            case 403:\n                Notification.warning({\n                    title: '用户权限提示',\n                    message: error.response.data.message,\n                    onClose() {\n                        router.push('/login')\n                    },\n                });\n                break;\n            case 404:\n                Notification.warning({\n                    title: '访问路径不正确',\n                    message: error.response.data.message,\n                });\n                break;\n            case 422:\n                Notification.warning({\n                    title: '温馨提示',\n                    message: error.response.data.message,\n                    onClose() {\n                        store.dispatch(\"logOut\")\n                        router.push('/login')\n                    },\n                });\n                break;\n            case 429:\n                Notification.warning({\n                    title: '温馨提示',\n                    message: error.response.data.message,\n                });\n                break;\n            case 500:\n                Notification.error({\n                    title: '网络提示',\n                    message: '服务器连接失败，请稍后再试',\n                });\n                break;\n            default:\n                Notification.error({\n                    title: '错误提示 ' + error.response.status,\n                    message: error.response.data.message,\n                });\n\n        }\n        return Promise.reject(error)\n    });\nexport default instance;\n\n```\n\n### Element按需加载\n\n> 网站快速成型工具\n> Element，一套为开发者、设计师和产品经理准备的基于 Vue 2.0 的桌面端组件库。详情配置请参考---[Element文档](https://element.eleme.cn/#/zh-CN/component/installation)\n\n借助 `babel-plugin-component`，我们可以只引入需要的组件，以达到减小项目体积的目的。\n安装 babel-plugin-component：\nnpm install babel-plugin-component -D\n\n```JavaScript\n//在babel.config.js配置\nconst plugins = [\n    [\n        \"component\",\n        {\n            \"libraryName\": \"element-ui\",\n            \"styleLibraryName\": \"theme-chalk\"\n        }\n    ]\n];\nmodule.exports = {\n    presets: [\n        '@vue/cli-plugin-babel/preset',\n    ],\n    plugins: plugins\n};\n```\n\n### 路由懒加载\n\n> 当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。详情配置请参考---[Vue Router指南](https://router.vuejs.org/zh/guide/advanced/lazy-loading.html)\n\n 当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了 \n\n```JavaScript\nimport('./Foo.vue') // 返回 Promise\n//下载syntax-dynamic-import 插件\nnpm install syntax-dynamic-import\n```\n\n> 本文为个人理解，若有不足，敬请指出","img":"https://p.pstatp.com/origin/137990001911d146aef4a","classty":"前端","channels":null,"name":"Baymax","click":1,"like":1,"is_show":1,"head_show":1,"share_show":1,"copyright_show":1,"message_show":0,"deleted_at":1,"created_at":"2020-09-01T03:03:42.000000Z","updated_at":"2020-10-16T07:11:10.000000Z","label":["Vue"],"view_count":1,"prevArticle":[{"id":2,"title":"Vue博客前端总结——知识准备"}],"nextrAticle":[{"id":4,"title":"Vue博客前端总结——多页面设置"}]}}